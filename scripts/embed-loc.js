// read strings.tsv and put into a JSON file

const fs = require("fs");

// In
const stringsTsvFilePath = "./localize/strings.tsv";
const languageCodeTsvFilePath = "./localize/language-code.tsv";
const manifestStringsTsvFilePath = "./localize/strings-manifest.tsv";
const manifestStringsTemplateJsonFilePath = "./localize/en.json";

// Out
const stringsJsonFilePath = "./src/core/localize/strings.json";
const languageEnumFilePath = "./src/core/localize/Language.ts";
const languageMapFilePath = "./src/core/localize/languageMap.ts";
const manifestStringsDirectory = "localize/languages";

// In Out
const localManifestPath = "./manifests/local.manifest.json";

const stringsTsv = fs.readFileSync(stringsTsvFilePath, "utf-8");

/**
 * Get all the languages that have all values present in the TSV text.
 * @param {strings} stringsTsv
 * @returns {string[][]} - array of rows, each row is an array of strings
 */
function getAllFullyPresentLanguagesInTsvText(stringsTsv) {
    // gather by language
    const rows = stringsTsv
        .trim()
        .split("\n")
        .map((line) => line.split("\t").map((value) => value.trim()));

    if (rows[0][0] === "Language") {
        rows[0][0] = "English";
    } else {
        console.error("First column must be 'Language'");
        process.exit(1);
    }

    // check each row has the same length
    const languages = rows.filter((row, index) => {
        const allValuesPresent = row.length === rows[0].length;
        if (!allValuesPresent) {
            console.error(`Row [${index}] has different length than the first row`);
        }
        return allValuesPresent;
    });
    return languages;
}

const languages = getAllFullyPresentLanguagesInTsvText(stringsTsv);

const stringsJson = {};
languages.reduce((acc, row) => {
    const [lang, ...values] = row;
    if (!acc[lang]) {
        acc[lang] = values;
    }
    return acc;
}, stringsJson);

// write to file
const jsonString = JSON.stringify(stringsJson, null, 4) + "\n";
fs.writeFileSync(stringsJsonFilePath, jsonString, "utf-8");
const languageList = Object.getOwnPropertyNames(stringsJson);
console.log(
    `Wrote ${Object.keys(stringsJson).length} languages {${languageList.join(", ")}} to ${stringsJsonFilePath}`
);

// Write Language Enum
const languagesEnum = `// Autogenerated file, do not manually modify

export enum Language {
    /**
     * Default language of the Office Application or English if not available.
     */
    Default = "Default",

    ${languageList.map((lang) => `${lang} = "${lang}"`).join(",\n    ")},

    /**
     * Pseudo language for testing.
     */
    Pseudo = "Pseudo",
}
`;
fs.writeFileSync(languageEnumFilePath, languagesEnum, "utf-8");
console.log(`Wrote Language enum to ${languageEnumFilePath}`);

// Write mapping table

const languageCodeTsv = fs.readFileSync(languageCodeTsvFilePath, "utf-8");

/**
 * [simple language, simple code][]
 * @type {[string, string][]}
 */
const languageCodeRows = languageCodeTsv
    .trim()
    .split("\n")
    .map((line) => line.split("\t"))
    .map((row) => {
        const [lang, code] = row;
        const simpleLang = lang.trim().split(" ")[0].trim();
        const simpleCode = code.trim().split("-")[0];
        return [simpleLang, simpleCode];
    });

const languageCodeMap = new Map(languageCodeRows);

const langCodes = languageList.map((lang) => {
    const code = languageCodeMap.get(lang);
    if (!code) {
        console.error(`Language ${lang} not found in language code mapping`);
        process.exit(1);
    }
    return [lang, code];
});

const languageMap = `// Autogenerated file, do not manually modify

import { Language } from "./Language";

/**
 * Map of display languages to Language enum values.
 * Only do prefix matching for the language code.
 * https://www.rfc-editor.org/info/bcp47
 */
export const languageMap = new Map<string, Exclude<Language, Language.Default>>([
    ${langCodes
        .map(([lang, code]) => {
            return `["${code}", Language.${lang}],`;
        })
        .join("\n    ")}
]);
`;
fs.writeFileSync(languageMapFilePath, languageMap, "utf-8");
console.log(`Wrote languageMap to ${languageMapFilePath}`);

// Write manifest translations

// Read manifest strings TSV
const manifestStringsTsv = fs.readFileSync(manifestStringsTsvFilePath, "utf-8");
const manifestStrings = getAllFullyPresentLanguagesInTsvText(manifestStringsTsv);

const manifestTemplateText = fs.readFileSync(manifestStringsTemplateJsonFilePath, "utf-8");
const manifestTemplate = JSON.parse(manifestTemplateText);

// For each language, create a JSON file with the strings, based off the main template
console.log(`\nCreating manifest strings for:`);
const [baseLanguage] = manifestStrings;
const completeLanguages = [];
for (const row of manifestStrings) {
    const values = row;
    const [lang] = values;
    const simpleLang = languageCodeMap.get(lang.trim());
    if (simpleLang === undefined) {
        console.error(`Language ${lang} not found in language code mapping`);
        process.exit(1);
    }
    console.log(`${lang} (${simpleLang})`);

    // construct the new object from template
    const newManifest = {};
    for (const key in manifestTemplate) {
        const valueToLocalize = manifestTemplate[key];
        let value = valueToLocalize;

        // If the value is a string, replace with translation
        if (typeof valueToLocalize === "string") {
            const index = baseLanguage.indexOf(valueToLocalize);
            if (index >= 0) {
                value = values[index];
            }
        }

        console.log(`   ${key} : ${valueToLocalize} : ${value}`);
        // Add every value to the new manifest
        newManifest[key] = value;
    }

    // Write the language file
    const outputFilePath = `${manifestStringsDirectory}/${simpleLang}.json`;
    const outputText = JSON.stringify(newManifest, null, 4) + "\n";
    fs.writeFileSync(outputFilePath, outputText);
    completeLanguages.push(simpleLang);
}

// Update manifest with available languages
const localManifestText = fs.readFileSync(localManifestPath, "utf-8");

/**
 * @type {{localizationInfo: {defaultLanguageTag: string; additionalLanguages: {languageTag: string; file: string;}[]}}}
 */
const localManifest = JSON.parse(localManifestText);

localManifest.localizationInfo.additionalLanguages = completeLanguages
    //.filter((lang) => lang !== localManifest.localizationInfo.defaultLanguageTag)
    .map((lang) => {
        return {
            languageTag: lang,
            file: `localize/languages/${lang}.json`,
        };
    });

const updatedLocalManifestText = JSON.stringify(localManifest, null, 4) + "\n";
fs.writeFileSync(localManifestPath, updatedLocalManifestText, "utf-8");
